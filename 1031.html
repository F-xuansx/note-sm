<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title> from 171101 to </title>
    <style>
        .state-body{
            /*设成inline-block，横向可伸缩*/
            display: inline-block;
            background: deepskyblue;
            position: relative;
        }
        .state-tip{
            width: 5px;
            height: 5px;
            background: red;
            position: absolute;
            top: 0px;
            right: 0px;
        }
        

    </style>
</head>
<body>

    <!-- 1.状态小标签-->
    <div class="state-body">
        可以伸缩的文字
        <div class="state-tip"></div>
    </div>
    


<script>
    /*
        1.slice()
        截取的起点，截取的终点（不包含）
    */
    ;
    (function () {
        var arr1=[1,2,3,4,5,6]
        var result1=arr1.slice(-3,-1)
//        console.log(arr1)     //不变
//        console.log(result1)    //4,5

        var arr2=[1,2,3,4,5,6]
        var result2=arr2.slice(1,3)
//        console.log(arr2)
//        console.log(result2)    //2,3
    })()



        /* 2.split() */
    ;
    (function () {
        var str='hello,my name is huo'
        var result=str.split(',')
//        console.log('str:', str)
//        console.log('result:',result)   // ['hello','my name is huo']
//        console.log('result[0]:',result[0])     // hello
    })()


        /* 3.window.location.href */
    ;
    (function () {
//        window.location.href='http://www.baidu.com'
    })()


        /* 4.encodeURIComponent() */
    ;
    (function () {
        var str='霍士强'
        var result=encodeURIComponent(str)
//        console.log('encode:', result)
        result=decodeURIComponent(result)
//        console.log('decode', result)
    })()


        /* 5.reduce */
    ;
    (function () {
        var arr=[1,2,3,4,5]
        var result=arr.reduce(function(pre,item){
            return pre + (item>2?1:0)
        }, 0)
//        console.log('arr:', arr)    //不变
//        console.log('result:', result)  //3
    })()
    

        /* 6.filter */
    ;
    (function () {
        var arr=[1,2,3,4,5]
        var result=arr.filter(function (item, index) {
            return item>2
        })
//        console.log('arr', arr)     //不变
//        console.log('result', result)   // [3, 4, 5]
    })()


        /* 7.map() */
    ;
    (function () {
        var arr=[1,2,3,4,5]
        var result=arr.map(function (item, index) {
            return item*10
        })
//        console.log('arr', arr)
//        console.log('result', result)   // [10, 20, 30, 40, 50]
    })()


        /* 8.获取url里的参数 */
    ;
    (function () {
        function getUrl(name){
            var reg = new RegExp("(^|&)"+ name +"=([^&]*)(&|$)");
            var r = window.location.search.substr(1).match(reg);
            if(r!=null)return  unescape(r[2]); return null;
        }
        var result=getUrl('id')
//        console.log(result)
    })()


        /* 9.冒泡排序 */
    ;
    (function () {
        var arr=[1,3,5,3,7,8,2,4]
        function mySort(arr){
            var d
            for(var i= 0;i<arr.length;i++){
                for(var j=i;j<arr.length;j++){
                    if(arr[i]>arr[j]){
                        d=arr[i]
                        arr[i]=arr[j]
                        arr[j]=d
                    }
                }
            }
            return arr
        }
        var result=mySort(arr)
//        console.log('arr', arr)     //变化
//        console.log('result', result)   //排序
    })()


        /* 10.sort()排序 */
    ;
    (function () {
//        看起来挺不错的：
        var arr=[1,3,5,3,7,8,2,4]
        var result=arr.sort()
//        console.log('arr', arr)     //变化
//        console.log('result', result)   //从小到大
        var result=result.reverse()
//        console.log('result reverse()', result)     //相反

//        然而：
        var arr2=[100,12,34,200]
        var result2=arr2.sort()
//        console.log('result2', result2)     //[100,12,200,34]
//        因为默认情况下sort()方法是按照ASCII排序的

//        因此：
        var arr1=[100,12,34,200]
        var result1=arr1.sort(function(a, b){
            return a-b    //正序  [12, 34, 100, 200]
//            return b-a      //倒序
        })
//        console.log('result1', result1)
    })()


        /* 11.快速排序 */
    ;
    (function () {
        var arr=[100,12,34,200,31,55,99]
        function quickSort(arr){
            //如果数组<=1,则直接返回
            if(arr.length<=1){return arr;}
            var pivotIndex=Math.floor(arr.length/2);
            //找基准，并把基准从原数组删除
            var pivot=arr.splice(pivotIndex,1)[0];
            //定义左右数组
            var left=[];
            var right=[];

            //比基准小的放在left，比基准大的放在right
            for(var i=0;i<arr.length;i++){
                if(arr[i]<=pivot){
                    left.push(arr[i]);
                }
                else{
                    right.push(arr[i]);
                }
            }
            //递归
            return quickSort(left).concat([pivot],quickSort(right));
        }
        var result=quickSort(arr)
//        console.log('arr', arr)
//        console.log('result', result)
    })()


        /* 12.希尔排序 */
    ;
    (function () {
        var arr=[100,12,34,200,31,55,99]
        function shellSort(arr){
            var N=arr.length;
            var h=1;
            while(h<N/3){
                h=3*h+1;//设置间隔
            }
            while(h>=1){
                for(var i=h; i<N; i++){
                    for(j=i; j>=h && arr[j]<arr[j-h]; j-=h){
                        swap(arr, j, j-h);
                    }
                }
                h=(h-1)/3;
            }
        }
        function swap(array, i, j){//两个数调换
            var temp =array[j];
            array[j]=array[i];
            array[i]=temp;
        }
        var result=shellSort(arr)
//        console.log('arr:', arr)    //正序
//        console.log('result:', result)      //无返回值
    })()


        /* 数组方法大全： */
        /* 13.join() */
    ;
    (function () {
        var arr=[1,3,4]
        var result=arr.join()
        var result2=arr.join('-')
//        console.log('arr:', arr)              //[1,3,4]
//        console.log('result join()', result)    //1,3,4
//        console.log('result join("-")', result2)    //1-3-4

//        利用join创建一个可以复制字符串的函数
        var str='闪萌'
        function repeatStr(str){
            return new Array(20).join(str)
        }
        var result3=repeatStr(str)
//        console.log('repeatStr:', result3)    //19个‘闪萌’
    })()
    

        /* 14.push() pop() unshift() shift() */
    ;
    (function () {
        var arr1=[1,2,3]
        var arr2=[4,5,6]
        var result=arr1.push(arr2)
//        console.log('arr1', arr1)   // [1,2,3,Array(3)]
//        console.log('arr1.push(arr2) :', result)    // 返回数量

        var arr=[11,22,33]
        ;[].push.apply(arr,arr2)    // [11,22,33,4,5,6]
//        console.log('arr', arr)

    })()


        /* 15.concat() */
    ;
    (function () {
        var arr1=[1,2,3]
        var arr2=[4,5,6]
        var result=arr1.concat(arr2)
//        console.log('arr', arr1)
//        console.log('arr1.concat(arr2)', result)
//        console.log('arr1.concat([11,111][22,222])', arr1.concat([11,111],[22,222]))    // 1,2,3,11,111,22,222
    })()


        /* 16.splice() */
    ;
    (function () {
        var arr=[1,2,3,4,5,6]
        var result1=arr.splice(2,0,'hi')    // [1,2,'hi',3,4,5,6]
        arr.splice(2,1,'hello')     // [1,2,'hello',3,4,5,6]
        arr.splice(2,1)     // [1,2,3,4,5,6]
//        console.log('arr', arr)
//        console.log('arr.splice(2,0,"hi")',result1)     //splice()无返回值
        arr.splice(-3,2)
//        console.log('arr.splice(-3,2):', arr)     // [1,2,3,6]
    })()


        /* 17.indexOf()  lastIndexOf() */
    ;
    (function () {
        var arr=[1,2,3,4,2,4,3]
        var result=arr.indexOf(3)   //2
        var result3=arr.indexOf(3,2)    //2
        var result4=arr.indexOf(3,3)    //6 (找第一个3，从index为3的地方开始找)
        var result2=arr.lastIndexOf(3)  //6
        var result5=arr.lastIndexOf(3,6)    //6
        var result6=arr.lastIndexOf(3,5)    //2 （找最后一个3，截止到index为3的地方）
//        console.log(result6)
    })()
    

        /* 18.forEach() */
    ;
    (function () {
        var arr=[1,2,3,4,2,4,3]
        var result=arr.forEach(function (item, index) {
//            console.log(item, index)      //执行逻辑
        })
//        console.log('arr', arr)   //原数组不变
//        console.log('result', result)   //forEach()也没有返回值
    })()


        /* 19.every() some() */
    ;
    (function () {
        var arr=[1,2,3,4,2,4,3]
//        every(): 都符合条件返回true
        var result=arr.every(function (item, index) {
            return item>0
        })
//        console.log(result)

//        some(): 只要有一个符合条件就返回true
        var result2=arr.some(function (item, index){
            return item>3
        })
//        console.log(result2)
    })()


        /* 20.includes() */
    ;
    (function () {
        var arr=[1,2,3,4,2,4,3]
        var str='hello world'
        var result=arr.includes(2)
        var result2=str.includes('wor')
//        console.log(result);    // true
//        console.log(result2)    // true
    })()



        /* 21.移动端解决ios滑动卡顿 */
    ;
    (function () {
//        在滑动项？上添加样式：
//        -webkit-overflow-scrolling: touch;
    })()



        /* 22.parseInt() */
    ;
    (function () {
        var num = 111
        var res1 = parseInt(num)
//        console.log('res1:', res1)    //111
        var res2 = parseInt(num, 2)
//        第二个参数表示以几进制解析
//        console.log('res2', res2)     //7

        var numWithStr = '123.4abc'
        var res3 = parseInt(numWithStr)
//        console.log('res3:', res3)  //123
        var res4 = parseFloat(numWithStr)
//        console.log('res4:', res4)  //123.4
        var res5 = +numWithStr
//        console.log('res5:', res5)  //NaN
    })()



        /* 23.charAt toUpperCase replace */
    ;
    (function () {
        var str = '我爱北京天安门 i love beijing'
        var res1 = str.charAt(0)
//        console.log('res1', res1)
        var res2 = str.toUpperCase()
//        console.log('res2:', res2)
        var res3 = str.replace('我爱', '我想去')
//        console.log('res3:', res3)
    })()



        /* 24.switch */
    ;
    (function () {
        var num = '2'
//        case后面的和num的比较是===全等比较
        switch (num){
            case 1:
                console.log('1')
                break
            case 2:
                console.log('2')
//                break
            case 3:
                console.log('3')
                break
            default :
//                console.log('default')
        }
    })()



        /* 25.数组的长度 */
    ;
    (function () {
        var arr = ['item1', 'item2']
//        console.log('arr.length:', arr.length)  //2
        arr[99] = 'item3'
//        console.log('arr.length:', arr.length)  //100
//        console.log(typeof(arr[98]))
    })()



        /* 26.undefined运算 */
    ;
    (function () {
//        console.log(undefined+1)
//        console.log(undefined+'1')
//        console.log(NaN+1)
//        console.log(NaN+'1')
    })()



        /* 27.symbol() */
    ;
    (function () {
        var s = Symbol()
//        console.log('typeof s:', typeof s)
        var s1 = Symbol('haha')
//        console.log('typeof s1:', typeof s1)
        s1.toString()
//        console.log('s1:', s1)

        var a = Symbol('a')
        var b = Symbol('a')
//        console.log('a:', a)        //Symbol(a)
//        console.log('b:', b)        //Symbol(a)
//        console.log('==?', a==b)    //false
//        console.log('===?', a===b)  //false

        setTimeout(()=>{
//            console.log('es6')
        }, 3000)
    })()



        /* 28.for in 和 for of */
//    for in用于遍历对象(如果遍历数组，会遍历数组的所有可遍历属性，包括原型。所以for in最好结合hasOwnProperty使用)
//    for of可以用于遍历数组，遍历的值
//    foreach遍历的时候，既不能用break终止遍历，又不能用return跳到外层函数
    ;
    (function () {
        var obj = {
            name: '小强',
            age: 18
        }
        for (key in obj){
//            console.log('key:', key)
//            console.log('value:', obj[key]) //小强 18
        }

        var arr = [1, 2, 5, 9, 4]
        for(value of arr){
//            console.log('value:', value)       //1 2 5 9 4
        }



        arr.forEach(function(value){
            if(value == 5){
                return
            }
//            console.log(value)  // 1 2 9 4
//            这里的return没有使其跳到外层函数，而是跳出了本次的遍历，继续下一次的遍历
        })

        arr.filter(function (value) {
            if(value == 5){
                return
            }
//            console.log(value)  // 1 2 9 4
//            这里也是？
        })
    })()



        /* 29.parseInt parseFloat Number*/
    ;
    (function () {
//        1.Number不能转换整体上不是数字的东西（既不是数字字符串，也不是数字）
        var num1 = Number(3.14)
        var num2 = Number('3.14')
//        var num3 = Number(3.14abc)
        var num4 = Number('3.14abc')
//        console.log('num1:', num1)  //3.14
//        console.log('num2:', num2)  //3.14
//        console.log('num3:', num3)  //报错：Invalid or unexpected token
//        console.log('num4:', num4)  //NaN

//        console.log(10 == 010)  //false
//        在比较的过程中，以0开头的被转换成了八进制
//        然鹅，在ES5的严格模式下，这个特性被移除了

//        console.log(Number(0x10))   //16
//        console.log(Number(0b10))   //2
//        console.log(Number(010))        //8
//        console.log(Number('010'))      //10

//        2.parseInt只能解析出整数部分
        var num5 = parseInt('3.14abc')
        var num6 = parseFloat('3.14abc')
//        console.log('num5', num5)   //3
//        console.log('num6', num6)   //3.14

//        3.parseInt的第二个参数可以设置基数，按这个基数的进制来进行解析
        var num7 = parseInt('0x123')    //291
        var num8 = parseFloat('0x123')  //0
        var num9 = parseInt('0x123', 16)    //291
        var num10 = parseInt('0x123', 10)   //0

//        console.log('num7:', num7)
//        console.log('num8:', num8)
//        console.log('num9:', num9)
//        console.log('num10:', num10)

//        从num7可以看出，parseInt可以自动识别出进制，并相应解析；同时，又能通过第二个参数，改变解析时使用的进制

//        4.算数运算符
//        算数运算符的转化原理是Number()
        var a = '123'
        var b = '123a'
        var num11 = +a  //123
        var num12 = +b  //NaN
//        console.log('num11:', num11)
//        console.log('num12:', num12)
    })()



        /* 30.date */
    ;
    (function () {
        var d = new Date()
        var myDate = d.getDate()    //日期
        var myDay = d.getDay()      //星期---星期日是0
        var myMonth = d.getMonth()  //月份---好像比正常月份少1
        var myFullYear = d.getFullYear()    //年份
//        console.log(myDate,myDay,myMonth,myFullYear)
    })()



        /* 31.RegExp */
    ;
    (function () {
        var reg = /^abc$/
        var reg2 = /^abc|abc$/
//        console.log(reg.test('abc'))        //true
//        console.log(reg.test('abcabc'))     //false
//        虽然^表示以什么开头，$表示以什么结尾，但是如reg所示的正则并不表示满足前两个条件即可，而是表示要完全匹配
//        console.log(reg2.test('abcabc'))    //true
    })()



        /* 32.闭包 */
    ;
    (function () {

        for(var i=0;i<10;i++){
            setTimeout(function () {
//                console.log(i)  // 十个10
            }, 1000)
        }

        for(var i = 0; i < 10; i++) {
//            setTimeout(function(i) {
//                console.log(i);
//            }, 1000);

//            这里为什么在setTimeout中传入i会得到undefined?????????
        }


        for(var i=0;i<10;i++){
            (function(e){
                setTimeout(function () {
//                    console.log(e) // 0-9
                }, 1000)
            })(i)
        }
    })()



        /* 33.javascript所有变量都可以当对象使用，除了null和undefined */
    ;
    (function () {
//        console.log(null.toString())          //报错
//        console.log(undefined.toString());    //报错
//        console.log([1, 2, 3].toString());
//        console.log(false.toString());
//        var obj = {name: 'xiaoqiang'}
//        console.log(obj.toString());
//        console.log(123.toString());          //报错
//        一个常见的误解是数字的字面值（literal）不能当作对象使用。这是因为 JavaScript 解析器的一个错误， 它试图将点操作符解析为浮点数字面值的一部分。
//        console.log((123).toString());
    })()



        /* 34.删除属性的唯一方法是使用 delete 操作符；设置属性为 undefined 或者 null 并不能真正的删除属性， 而仅仅是移除了属性和值的关联。 */
    ;
    (function () {
        var obj = {
            name: 'xiaoqiang',
            gender: 'man',
            face: 'cool'
        }
        obj.name = null
        obj.gender = undefined
        delete obj.face
        for(var i in obj){
            if(obj.hasOwnProperty(i)){
//                console.log(i+':'+obj[i])
            }
        }
    })()



        /* 35.obj有没有length属性(没有)。Object.keys() */
    ;
    (function () {
        var obj = {
            name: '小强',
            age: '12'
        }
//        console.log(obj.length) //undefined

        var keysed = Object.keys(obj)
        var len = keysed.length
//        console.log(len)

    })()



        /* 36.将参数从一个函数传递到另一个函数的方法 */
    ;
    (function () {
        function foo(){
            bar.apply(null, arguments)
//            bar函数用foo函数的argu?
        }
        function bar(a, b, c){
//            干活
        }
    })()



        /* 37.构造函数的返回 */
    ;
    (function () {
//           通过new关键词调用的是构造函数
//           正常情况下返回的都是返回this对象（也就是新创建的对象）
//        特殊情况就是，被new调用的函数有显示的return且return的是一个对象

        function Test(){
            this.value = 2
            return {
                foo: 'hhh'
            }
        }

        var obj = new Test()
//        console.log(obj.value)  //undefined
//        console.log(obj.foo)    //'hhh'

//        但是new Test（）并不会将Test的prototype指向返回的这个对象
//        而是指向new出来的对象（这个对象已经被new出来，只是没有被返回）

    })()

    

        /* 38.作用域与命名空间 */
    ;
    (function () {
        var items = [1, 2, 3, 4, 5, 6, 7, 8, 9];
        for(var i = 0; i < 3; i++) {
            subLoop();
        }

        function subLoop() {
            // subLoop 函数作用域
            for(i = 0; i < 4; i++) { // 没有使用 var 声明变量
                // 干活
//                console.log(items[i])
            }
        }
        //1, 2, 3, 4
//        因为subLoop中的i没有var，所以是全局变量，所以只会进行一轮，而不是预期中的三轮

//        局部变量的声明方式：1.参数；2.var

        if(!aBianliang){
            var aBianliang = {}
//            console.log('ok')   //ok
        }
//      因为这里的“aBianliang”被var过

//        #2
        if(typeof bBianliang){
//            console.log(typeof bBianliang)         //undefined
//            console.log(typeof(typeof bBianliang))  //string
//            因为typeof的返回结果是string类型（无论测试结果是什么类型），所以经常用typeof做判断而且不会有报错的危险
        }
    })()



        /* 39.变量查找顺序 */
    ;
    (function () {
//        比如，当访问函数内的 foo 变量时，JavaScript 会按照下面顺序查找：
//        1.当前作用域内是否有 var foo 的定义。
//        2.函数形式参数（形参）是否有使用 foo 名称的。
//        3.函数自身是否叫做 foo。
//        4.回溯到上一级作用域，然后从 1 重新开始。
    })()



        /* 40.遍历时缓存数组的长度 */
    ;
    (function () {
        var list = [1, 2, 3, 4, 5];
        for(var i = 0, l = list.length; i < l; i++) {
//            console.log(list[i]);
        }
//        上面 l = list.length 就是缓存数组的长度，不用每次遍历都访问数组的长度，节省了性能
    })()



        /* 41.Array构造函数 */
    ;
    (function () {
//        1.创建数组的时候推荐使用字面量方式，因为new Array()的方式不好用
        var arr1 = new Array(1,2,3,4)   //传多个数字的时候，表示一个所见即所得的数组
        var arr2 = new Array(6)         //传一个数字的时候，表示一个长度为该数字的数组，而且还是空的（只是设置了长度）
//        console.log(arr1)   //[1,2,3,4]
//        console.log(arr2)   //[empty * 6]
        var arr3 = new Array('6')       //传一个的时候，传成字符串，“也不能”达到得到一个元素只有一个的数组的目的
//        console.log(arr3)       //["6"]

//        作用： 可以用来重复字符串
        var result = new Array(6).join('帅哥')
//        console.log(result)
    })()



        /* 42.检测一个对象的类型 */
    ;
    (function () {
//        console.log(typeof [1,2,3])                 //"object"
//        console.log(typeof (new String('str')))     //"object"
//        用typeof大多数返回的是“object”，并不能起到检测类型的作用
//        唯一的作用： 测试未定义的变量(见#2)

//        检测一个对象的最好的方法：
//        Object.prototype.toString
        var obj={
            res1: Object.prototype.toString.call('hello'),
            res2: Object.prototype.toString.call(123),
            res3: Object.prototype.toString.call(false),
            res4: Object.prototype.toString.call(null),
            res5: Object.prototype.toString.call(undefined),
            res6: Object.prototype.toString.call({}),
            res7: Object.prototype.toString.call([]),
            res8: Object.prototype.toString.call(new Date())
        }

        for(var i=1;i<=8;i++){
            var res = 'res' + i
//            console.log(obj[res])
        }
    })()



        /* 43.Number()和new Number() */
    ;
    (function () {
//        console.log(Number(10) == new Number(10))   //true
//        console.log(Number(10) === new Number(10))  //false
//        console.log(Object.prototype.toString.call(Number(10)))         //[object Number]
//        console.log(Object.prototype.toString.call(new Number(10)))     //[object Number]
//        console.log(typeof Number(10))      //number
//        console.log(typeof new Number(10))  //object

//        由此可以看出，===的类型的比较应该是typeof的方式

//        console.log(typeof (new Number(10) + 0))    //number
    })()



        /* 44.为什么不使用eval */
    ;
    (function () {
//        绝对不要使用eval，所以也不要学习什么是eval，以免你记住了eval怎么用，但却忘记了不能用eval
    })()


</script>
</body>
</html>