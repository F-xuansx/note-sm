1.什么是前端？
2.什么是闭包？
$闭包
百度百科：闭包就是能够读取其他函数内部变量的函数。
这个能够读取某函数内部变量的函数，必定就是某函数的内部函数，或者代理某函数内部函数的函数。
百度百科又说，在本质上，闭包是将函数内部和函数外部连接起来的桥梁。
怎样理解只有内部的函数可以读取函数的变量？
全局就相当于一个大广场，
每当有一个函数在大广场建立，就相当于在大广场“自立门户”，盖了一座房子；
如果在这个房子里又有房子建立，就相当于在这个房子中又“自立门户”；
以此类推。
同时呢，住在一个房子内的人，肯定有这把房子的钥匙，
如果这个人不断的在房子里建房子，也就是函数嵌套，
那这个人一定有各个房子的钥匙，也就是它可以一层一层访问外边，
除了这个房子的人，外边的人并不能访问他的房子。

每当有一个函数建立，就好像又雇佣了一个人。

闭包Vs对象：
函数是临时雇佣，干完活就辞退。
对象和变量更像是长期工。
闭包：函数内部的函数可以访问函数内部的变量，将函数内部的函数赋值给函数外部的变量，然后调用这个变量；
 vs
对象：对象内部的方法可以访问对象内部的变量，调用这个对象的方法。
前者像是，心血来潮看到一个干活的的团队挺适合，就把它顾永成长期工了。
后者更像是，本来就是长期工，自己培养的一个小团队（那前者就是认领、领养的）。
用“心血来潮”来形容，是因为相比于创建了一个对象然后调用对象的方法（有预谋要用哪些变量，做什么事情），
将一个函数内部的函数保留下来显得更没有预谋（关注点在其实现的功能上，所以它引用着哪些变量根本就不知道）。
自己培养一只团队，肯定对其规模是比较了解的。
而心血来潮雇佣了一只团队，却发现它是属于一个更大的团队下的一个小团队，那就需要把整个大团队买下来。一不小心就养不起了。（闭包的缺点）
如果返回的函数内部的函数没有引用外部函数的任何变量会如何？
那也是内部的先干完活，外部的才有可能撤退；内部干的活就是外部干的活的一部分。

如果闭包不是单指能够读取其他函数内部变量的函数，而是指这个心血来潮的雇佣方式的话。
那么闭包就可以解释为：。


function(){}中的()中的东西是雇佣function的记忆，大部分()里没有东西就是说大部分是没有记忆的。
（）里面是var的东西？

函数是干完就走的，对象是被留下来的。

一般情况下，函数是干完就走的，这就是执行环境的生命周期在函数执行完之后销毁。
但是一旦将函数赋值给变量，那么就相当于把它留下来了。

为什么局部执行环境可以访问父环境乃至全局环境？
因为对于父环境来说，局部执行环境都是雇佣来做某件事情的（实现某种功能），
比如说一个房地产商雇佣一个装修的团队，但是不让他知道自己的大楼在哪儿，就根本不能干活。
一个人雇佣保姆，却不让他进家。
所以局部执行环境就有必要知道雇佣他的人在干什么。

var相当于自己设立了一个职位。
var a=1
就是设置了一个职位a.
var了而没有赋值，就相当于有这个职位而没人。但是执行的时候是按照自己团队有这个职位就不往上层去找了的规则找的，
所以这个职位就会变成undefined并会报一些错。
没var的话，就根本没有这个职位，肯定就是直接管雇佣他们的团队去要人的。他可能会说，我们做这个需要一个前端来干什么什么。。

假如说不管是父函数函数子函数、他们都是需要隐私的，那么子函数实现了，
而父函数却没有实现，
可以说是，父函数没有办法实现。
因为他雇佣一支团队来帮他完成某件事情，总得让别人知道他要完成什么事情吧。
他不知道子函数究竟是怎么完成的，就像他的父函数也根本不知道她是怎么完成的一样。

闭包是为了代替对象的？
闭包的作用是保护函数内的变量安全？
函数内的变量本来就是安全的，因为函数外 部不能访问函数内部本来就是函数的特性。
function a(){
 var i=0
 function b(){
  alert(++i)
 }
 return b
}
var c=a()
c()

所有的作用和优点都是相对的。
而闭包（虽然目前还是不明确说的是啥）
的作用和优点大部分都是相对于对象来说的 。
在网上的很多解释上都忽略了这一点，就是 根本没有参照物。
比如，
1.“保护函数内的变量安全。以最开始的例 子为例，函数a中i只有函数b才能访问，而无 法通过其他途径访问到，因此保护了i的安全 性。”
“函数内的变量安全”和“闭包”可以说是 没有关系的，因为函数内的变量是“相对对 象”安全。
2.“在内存中维持一个变量。依然如前例， 由于闭包，函数a中i的一直存在于内存中， 因此每次执行c()，都会给i自加1”
“在内存中维持一个变量”是函数代替对象 的一个必须的因素，因为对象就是同时保存 变量和方法的，要实现某个功能也基本上要 在内存中维持一个变量。在内存中维持一个 变量的实现，主要通过的是函数的赋值保存 。（但是在闭包中一般是函数中被返回的函 数的赋值保存）。函数也是对象，只不过函 数是干完就跑的对象？
那么对象是没有跑吗？
函数和对象什么区别？
作用域链有对象的事吗？
https://www.zhihu.com/question/34210214 ?sort=created
http://www.jb51.net/article/24101.htm

一个团队被雇佣之后，他是可以不断地往上去要东西的。
他需要的东西，自身没有，就去雇佣他的那里要，再没有就问雇佣他的人是被谁雇佣的的，然后再要。
这就是作用域链。
后面还看到“先找原型链，再找作用域链”？
先问自己的帮会有没有，然后管雇佣者去要？

函数是内部的函数，是在团队中成立的团队？
同时团队只能找他的上级或上上级团队..？
那么怎么解释“干完就走”？

一个被雇佣者，和他需要的所有的东西（包括他朝上面要到的东西），就是一个闭包。
闭包就是一个“可以正常工作的雇佣者”？
闭包确实是一个可以正常工作的函数。他正常工作的前提就是他需要的东西都在。所以雇佣他的人不能走。
作用域链是函数创建的时候就形成的吗？
如果是的话，就说明函数被创建的时候他的能朝谁要东西的关系就已经定了，基本上都是一个正常工作的被雇佣者。
后续想确保正常工作的时候，必须保持这个雇佣关系。否则很可能需要的东西没处要。

「函数」和「函数内部能访问到的变量」（也叫环境）的总和，就是一个闭包。
但是，「我听说闭包是需要函数套函数，然后 return 一个函数的呀！」
前者是闭包的定义。
后者更多是在解释“如何利用闭包”。

而且在“如何利用闭包”的问题上，主要利用的是闭包的特点。
即内部函数可以访问外部函数的变量。

“如何利用闭包”也不能直白的解释后者，后者的真正阴谋是“全局环境下实现某个功能，同时尽可能少增加全局变量
（也可以是隐藏某个变量，如果这样的话，就可以解释成不希望公司里出现某些人，虽然他对这个功能的实现是有用的）”。
如果全局是一个老板的公司，翻译过来就是，老板想做成什么事，但是不希望公司增加很多人（主要是怕乱）。
那他想到了几点：
一，雇佣其它团队不会使自己的公司增加人。
二，让一个人和做事的最直接的团队保持联系就可以了（变量保存函数相当于“保持联系”？）。
三，被雇佣的团队自己会去找雇佣他的团队找需要的东西，不担心这个最直接的团队干不了活。
第三点保证了“最直接的团队”的存在，否则就只能联系整个和功能相关的最大的团队了。
同样，为了实现“全局环境下实现某个功能，同时尽可能少增加全局变量”，程序员也想到了几点：
一，函数独立作用域，不会增加全局变量。
二，把实现功能的函数return出来就可以了。
三，内部函数可以访问外部函数的变量（闭包），所以return出来的函数才能正常工作。

作用域链相当于留联系方式？


闭包的目的是从外部获取函数中的变量吗？ 如果是的话，我直接将这个变量return返回不可以吗？
：目的是“全局环境下实现某个功能，同时尽可能少增加全局变量”
return的可能是变量，可能是与这个变量有关的值，可能是改变这个变量的方法


function 做早饭(){
  var 包子 = 面
}


闭包：经理和人事之间的秘密。

大家好，我是“真强”公司董事长小强。

经理有什么事情就找人事，因为人事对我们这些员工都比较了解，胖的、瘦的，帅的是小强。


当某个函数被调用时，会创建一个执行环境及相应的作用域链。

变量对象就相当于人事、管家，管自己公司有那些人的。
作用域链就是留下上级以及上上级的人事的联系方式，通过他们可以找到他们公司的人或东西。
（每雇佣一个团队的时候，人事就会留下自己的电话，说，有什么需要就联系我）
每个执行环境都有一个与之关联的“变量对象”，环境中定义的所有变量和函数都保存在这个对象中。作用域链保存相关的“变量对象”。

一个公司把事情干完了，人事就会被通知，把自己管理的这堆垃圾带走，我们这里就不留你们了。
但是作用域链是负责和相关的人事联系的，他得知在自己还没干活的情况下，有人事被通知“将你们这堆垃圾带走”的时候，他就会说不行、
如果你们把他们带走我们有可能干不了活（也可以是说，因为被雇佣的公司一般都会用到雇佣者的人力，所以只要有人还保留某个人事的联系方式，
说明还可能有用，人事就不会被通知走人）。
函数的变量对象一般在函数调用结束后被销毁，被垃圾回收。

闭包1：能够访问另一个函数作用域中变量的函数。（return的、window.xxx的）
闭包2：当一个内部函数被其外部函数之外的变量引用时，就形成了一个闭包。
闭包3：函数和函数内部能访问到的变量的总和，就是一个闭包。（经理能通过人事联系到的所有人、资源）


闭包：
每个函数，都有一个本公司的名单，这就是变量对象；
同时，又有他的所有父函数的名单，即其它函数自己的变量对象；
自己的变量对象+其它函数的变量对象=作用域；
作用域也就是属于他的员工名单。
当某个函数执行完成后，他的名单被销毁，名单上的人会被标记并杀害。
这就是垃圾处理。
但是，如果内部函数没有return,或者被保存成一个变量？
由于它拥有一份名单，名单上的人就会免于“被杀害”。

见javascript高级程序设计p179

3.什么是继承？
4.什么是原型链？
原型链是这个过程中物质共享。

new Foo()的时候就相当于加入Foo派，然后他就能得到一把Foo提供的通往其prototype钥匙，然后就可以去Foo的prototype里面拿东西了。

new Bar() instanceof Bar的意思就是“new Bar()能访问到Bar提供的仓库吗？”

//      正常情况下，一个对象的prototype里保存着constructor属性，construcetor里是创建这个对象的函数
//      对于构造函数来说，就是再他为跟随者提供的公共空间prototype中，不但有一把通向Object的钥匙，
//      还有一把可以找到自己这个团队（函数是团队）的钥匙？

也就是说这个函数实际上是一直存在的，不管他存在哪儿。有一个地址可以找到他。

相对于作用域，原型就像是入会、进社团、加入某某势力、参加天地会。

而雇佣关系中，函数干完就走，其中影响的运行内存，相当于管他们吃饭？

5.什么是内存泄漏？
6.什么是this?
this就是“你”的意思。
函数执行的this指的是window，就好比“君”代指的皇帝一样。
构造函数的this指向是新创建的对象，就好像招人的人给被招的人开会，说你一样。
你的什么是什么，你碰到什么问题的时候怎么办。

this就是君，就是老大的意思。
只要不是xxx.xxx()的形式，那么一个函数的运行时的老大都是window。
而xxx.xxx()的形式，就是说现在xxx是老大，然后来运行什么。



2018/6/4
Object、Array、String、Object都是new Function之后出来的。它们都是函数？
String.__proto__ == Function.prototype
true
Date.__proto__ == Function.prototype
true


2018/6/26
为什么要定义变量？
用着方便。
变量赋值：
变量的名字，就好比人的名字。
基本类型的变量赋值：
数字、字符串、布尔类型的赋值，就是直接把一个名字和值联系在一起。
var a = '程序员'、 好比a是程序员；
var b = false、 可以理解成b是一个坏人；
var c = 100、 可以认为c就代表100，他可以是100块，也可以是100斤，这个要看你后边的代码怎么用。
而一个值是undefined，大部分情况下是，你创造了一个人物但是没有给他任何角色，或者说你在使唤一个根本就没有的角色。
引用类型的赋值：
引用类型之所以叫引用类型，就是因为引用。
不是所有的人都知道引用、指针，但是大多数人应该都知道钥匙。
无论是基本类型还是引用类型，赋值的过程都是“给东西”的过程。
基本类型的，就是直接给。
var a='小强真帅'
var b=a
上面就是说，你把‘小强真帅’的消息给了a， 然后a又把这个消息给了b。
所以赋值就是“给”。
而且这是一种“单纯复制、给完就跑”的一次性买卖。
b=a之后，
a虽然将‘小强真帅’这条真理给了b，
但是a自己依然还保存着自己的‘小强真帅’的认知。
这是单纯复制，有啥给啥，相对对象来说的。
b='小强不帅'
并不影响a='小强真帅'
即给完就跑，一次性买卖；
a与b的关系就像是菩提老祖和孙悟空，
从哪里来，回哪里去，讲的就是他们的关系：
虽然a曾经给过b东西，
但是日后b惹出什么祸来都与悟空无关。

对象的赋值，也是“给”。
但是不像基本类型那样，你看见它是什么、它给的就是什么。
基本类型，我var a=100
表示给了a 100元。
给了就到手里了。
引用类型，我var b={
    c: 200,
    d: '下雨要打伞'
}
表示给了b 一个有200元的c和知道‘下雨要打伞’的d吗，
而且给了就到手里了吗。
显然b是拿不了这么多东西的。
同时，这些b确实拥有这些东西，
怎么办到的？
首先是建了一个屋子，
然后再在这个屋子里创建了这些人物，
最后给b一把这个屋子的钥匙，
于是b就拥有了这个东西。
基本类型的赋值，
好比你有一部手机，然后买了相同一部手机交到女朋友手里。
引用类型的赋值，
好比你有一套房，然后你把这套房的钥匙复制了一把交到女朋友手里。
任何我们看到的对象的赋值，其实都是钥匙的传递，只是我们看不到。

function Person(){}
var tom = new Person()
Person.prototype.sayHi = function(){
    console.log('hihihihihihi')
}
tom.sayHi()     // 正常

function Person(){}
var tom = new Person()
Person.prototype = {
    sayHi: function(){
        console.log('ssshihihihihi')
    }
}
tom.sayHi()     // 报错

第一种正常的情况，tom的__proto__和Person.prototype的钥匙是去往相同房间的钥匙，
虽然一开始的时候给tom的__proto__放钥匙的时候，并没有sayHi方法，但是在tom执行sayHi的时候，
我们利用prototype的钥匙，及时进房间把这个放了进去，所以就完美执行了。

第二种明显是一种对prototype的赋值行为，而赋值对象又相当于是给钥匙。
也就是说，Person.ptototype换了另一把钥匙，开了另一个房间，做了一些__proto__不知道的事情，
因为他们已经是两个房间的人。