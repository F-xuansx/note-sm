1.什么是前端？
2.什么是闭包？
$闭包
百度百科：闭包就是能够读取其他函数内部变量的函数。
这个能够读取某函数内部变量的函数，必定就是某函数的内部函数，或者代理某函数内部函数的函数。
百度百科又说，在本质上，闭包是将函数内部和函数外部连接起来的桥梁。
怎样理解只有内部的函数可以读取函数的变量？
全局就相当于一个大广场，
每当有一个函数在大广场建立，就相当于在大广场“自立门户”，盖了一座房子；
如果在这个房子里又有房子建立，就相当于在这个房子中又“自立门户”；
以此类推。
同时呢，住在一个房子内的人，肯定有这把房子的钥匙，
如果这个人不断的在房子里建房子，也就是函数嵌套，
那这个人一定有各个房子的钥匙，也就是它可以一层一层访问外边，
除了这个房子的人，外边的人并不能访问他的房子。

每当有一个函数建立，就好像又雇佣了一个人。

闭包Vs对象：
函数是临时雇佣，干完活就辞退。
对象和变量更像是长期工。
闭包：函数内部的函数可以访问函数内部的变量，将函数内部的函数赋值给函数外部的变量，然后调用这个变量；
 vs
对象：对象内部的方法可以访问对象内部的变量，调用这个对象的方法。
前者像是，心血来潮看到一个干活的的团队挺适合，就把它顾永成长期工了。
后者更像是，本来就是长期工，自己培养的一个小团队（那前者就是认领、领养的）。
用“心血来潮”来形容，是因为相比于创建了一个对象然后调用对象的方法（有预谋要用哪些变量，做什么事情），
将一个函数内部的函数保留下来显得更没有预谋（关注点在其实现的功能上，所以它引用着哪些变量根本就不知道）。
自己培养一只团队，肯定对其规模是比较了解的。
而心血来潮雇佣了一只团队，却发现它是属于一个更大的团队下的一个小团队，那就需要把整个大团队买下来。一不小心就养不起了。（闭包的缺点）
如果返回的函数内部的函数没有引用外部函数的任何变量会如何？

如果闭包不是单指能够读取其他函数内部变量的函数，而是指这个心血来潮的雇佣方式的话。
那么闭包就可以解释为：。


function(){}中的()中的东西是雇佣function的记忆，大部分()里没有东西就是说大部分是没有记忆的。
（）里面是var的东西？

函数是干完就走的，对象是被留下来的。

一般情况下，函数是干完就走的，这就是执行环境的生命周期在函数执行完之后销毁。
但是一旦将函数赋值给变量，那么就相当于把它留下来了。

为什么局部执行环境可以访问父环境乃至全局环境？
因为对于父环境来说，局部执行环境都是雇佣来做某件事情的（实现某种功能），
比如说一个房地产商雇佣一个装修的团队，但是不让他知道自己的大楼在哪儿，就根本不能干活。
一个人雇佣保姆，却不让他进家。
所以局部执行环境就有必要知道雇佣他的人在干什么。

var相当于自己设立了一个职位。
var a=1
就是设置了一个职位a.
var了而没有赋值，就相当于有这个职位而没人。但是执行的时候是按照自己团队有这个职位就不往上层去找了的规则找的，
所以这个职位就会变成undefined并会报一些错。
没var的话，就根本没有这个职位，肯定就是直接管雇佣他们的团队去要人的。他可能会说，我们做这个需要一个前端来干什么什么。。

假如说不管是父函数函数子函数、他们都是需要隐私的，那么子函数实现了，
而父函数却没有实现，
可以说是，父函数没有办法实现。
因为他雇佣一支团队来帮他完成某件事情，总得让别人知道他要完成什么事情吧。
他不知道子函数究竟是怎么完成的，就像他的父函数也根本不知道她是怎么完成的一样。

闭包是为了代替对象的？
闭包的作用是保护函数内的变量安全？
函数内的变量本来就是安全的，因为函数外 部不能访问函数内部本来就是函数的特性。
function a(){
 var i=0
 function b(){
  alert(++i)
 }
 return b
}
var c=a()
c()

所有的作用和优点都是相对的。
而闭包（虽然目前还是不明确说的是啥）
的作用和优点大部分都是相对于对象来说的 。
在网上的很多解释上都忽略了这一点，就是 根本没有参照物。
比如，
1.“保护函数内的变量安全。以最开始的例 子为例，函数a中i只有函数b才能访问，而无 法通过其他途径访问到，因此保护了i的安全 性。”
“函数内的变量安全”和“闭包”可以说是 没有关系的，因为函数内的变量是“相对对 象”安全。
2.“在内存中维持一个变量。依然如前例， 由于闭包，函数a中i的一直存在于内存中， 因此每次执行c()，都会给i自加1”
“在内存中维持一个变量”是函数代替对象 的一个必须的因素，因为对象就是同时保存 变量和方法的，要实现某个功能也基本上要 在内存中维持一个变量。在内存中维持一个 变量的实现，主要通过的是函数的赋值保存 。（但是在闭包中一般是函数中被返回的函 数的赋值保存）。函数也是对象，只不过函 数是干完就跑的对象？
那么对象是没有跑吗？
函数和对象什么区别？
作用域链有对象的事吗？
https://www.zhihu.com/question/34210214 ?sort=created
http://www.jb51.net/article/24101.htm

一个团队被雇佣之后，他是可以不断地往上去要东西的。
他需要的东西，自身没有，就去雇佣他的那里要，再没有就问雇佣他的人是被谁雇佣的的，然后再要。
这就是作用域链。
后面还看到“先找原型链，再找作用域链”？
先问自己的帮会有没有，然后管雇佣者去要？

函数是内部的函数，是在团队中成立的团队？
同时团队只能找他的上级或上上级团队..？
那么怎么解释“干完就走”？

一个被雇佣者，和他需要的所有的东西（包括他朝上面要到的东西），就是一个闭包。
闭包就是一个“可以正常工作的雇佣者”？
闭包确实是一个可以正常工作的函数。他正常工作的前提就是他需要的东西都在。所以雇佣他的人不能走。
作用域链是函数创建的时候就形成的吗？
如果是的话，就说明函数被创建的时候他的能朝谁要东西的关系就已经定了，基本上都是一个正常工作的被雇佣者。
后续想确保正常工作的时候，必须保持这个雇佣关系。否则很可能需要的东西没处要。

「函数」和「函数内部能访问到的变量」（也叫环境）的总和，就是一个闭包。
但是，「我听说闭包是需要函数套函数，然后 return 一个函数的呀！」
前者是闭包的定义。
后者更多是在解释“如何利用闭包”。

而且在“如何利用闭包”的问题上，主要利用的是闭包的特点。
即内部函数可以访问外部函数的变量。

“如何利用闭包”也不能直白的解释后者，后者的真正阴谋是“全局环境下实现某个功能，同时尽可能少增加全局变量
（也可以是隐藏某个变量，如果这样的话，就可以解释成不希望公司里出现某些人，虽然他对这个功能的实现是有用的）”。
如果全局是一个老板的公司，翻译过来就是，老板想做成什么事，但是不希望公司增加很多人（主要是怕乱）。
那他想到了几点：
一，雇佣其它团队不会使自己的公司增加人。
二，让一个人和做事的最直接的团队保持联系就可以了（变量保存函数相当于“保持联系”？）。
三，被雇佣的团队自己会去找雇佣他的团队找需要的东西，不担心这个最直接的团队干不了活。
第三点保证了“最直接的团队”的存在，否则就只能联系整个和功能相关的最大的团队了。
同样，为了实现“全局环境下实现某个功能，同时尽可能少增加全局变量”，程序员也想到了几点：
一，函数独立作用域，不会增加全局变量。
二，把实现功能的函数return出来就可以了。
三，内部函数可以访问外部函数的变量（闭包），所以return出来的函数才能正常工作。

次要：
闭包的目的是从外部获取函数中的变量吗？ 如果是的话，我直接将这个变量return返回不可以吗？
：目的是“全局环境下实现某个功能，同时尽可能少增加全局变量”
return的可能是变量，可能是与这个变量有关的值，可能是改变这个变量的方法


3.什么是继承？
4.什么是原型链？
原型链是这个过程中物质共享。

new Foo()的时候就相当于加入Foo派，然后他就能得到一把Foo提供的通往其prototype钥匙，然后就可以去Foo的prototype里面拿东西了。

new Bar() instanceof Bar的意思就是“new Bar()能访问到Bar提供的仓库吗？”

//      正常情况下，一个对象的prototype里保存着constructor属性，construcetor里是创建这个对象的函数
//      对于构造函数来说，就是再他为跟随者提供的公共空间prototype中，不但有一把通向Object的钥匙，
//      还有一把可以找到自己这个团队（函数是团队）的钥匙？

也就是说这个函数实际上是一直存在的，不管他存在哪儿。有一个地址可以找到他。

相对于作用域，原型就像是入会、进社团、加入某某势力、参加天地会。

而雇佣关系中，函数干完就走，其中影响的运行内存，相当于管他们吃饭？

5.什么是内存泄漏？
6.什么是this?
this就是“你”的意思。
函数执行的this指的是window，就好比“君”代指的皇帝一样。
构造函数的this指向是新创建的对象，就好像招人的人给被招的人开会，说你一样。
你的什么是什么，你碰到什么问题的时候怎么办。

this就是君，就是老大的意思。
只要不是xxx.xxx()的形式，那么一个函数的运行时的老大都是window。
而xxx.xxx()的形式，就是说现在xxx是老大，然后来运行什么。
